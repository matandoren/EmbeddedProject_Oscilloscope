#include <p32xxxx.h>
#pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_1, FWDTEN = OFF
#pragma config POSCMOD = HS, FNOSC = PRIPLL, FPBDIV = DIV_8
void initPortB(void);
void print_led(char x);
void initPortD(void);
void initPortE(void);
void initPortF(void);
void initPortG(void);
void busy(void);
void scope();


void print_message1(void);
void print_message2(void);
void print_message3(void);
void print_message4(void);
void print_message5(void);
void print_message6(void);


int num_led,num_lcd,i,keyVal,column,tris_map;



char string1[]= "Mode1-sinus   ";
char string2[]= "Mode2-square  ";
char string3[]= "Mode3-saw wave";
char string4[]= "Mode4-triangle";
char string5[]= "Mode5-Maatafa ";
char string6[]= "Mode6-circule ";




	char control2[7]={0x38,0x38,0x38,0xe,0x6,0x1,0xc8};
	char control[7]={0x38,0x38,0x38,0xe,0x6,0x1,0xc2};			//set DDRAM=0xc5 (the middle of the second row)

void delay(int j);
void delay0(void);


void main(void)
{ 

	int i,data;
	char flag=0;
	int RUN_ZERO[4] = {0xee,0xdd,0xbb,0x77};
	int scan_key_code_ascii[32]={0xee,'1',0xde,'2',0xbe,'3',0x7e,'A',
                                 0xed,'4',0xdd,'5',0xbd,'6',0x7d,'B',
                                 0xeb,'7',0xdb,'8',0xbb,'9',0x7b,'C',
                                 0xe7,'*',0xd7,'0',0xb7,'#',0x77,'D'};  



  	initPortB();
	initPortD();
	initPortE();
	initPortF();
	initPortG();
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	PORTG = 0x00;	
	PORTF = 0x07;
    flag=0; 

    while(1)
    {	
	column = 0;   
        while(1)
        {	
	    	PORTG = 0x00;
            	PORTF = 0x07;
		PORTE = RUN_ZERO[column];
	       	delay0();	
		keyVal = PORTB & 0x0F;

		if(keyVal != 0x0f)
            	{ 
	        	flag=1;
			break;
            	}

            	column++;
		if(column==4)column = 0;  
	}
								
	num_led=((RUN_ZERO[column]&0xf0)|(keyVal));

	for(i=0;i<32;i+=2)
	{
		if(num_led==scan_key_code_ascii[i])    
                break;
	}

	scope();

      }         
}
 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void scope()
{
	unsigned char s,x=0,y=0,d=0;
 	char flag_scan=1;
	char data[180];


	PORTG = 0x00;
 	PORTF = 0x07;
    while(1)
    {
    	s=scan_key();
     	if(s!=0xff)
         	flag_scan=s;
  

      if(flag_scan=='1')    
        {
			initPortF();
			print_message1();

    		while(1)
          	{
				PORTF = 0x05;			//Select DAC channel A
     			while(1)
             	{
					for(x=0;x<180;x++)
                    {
                    	PORTE=127+127*sin((2*3.14*x)/180);
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
                    }

          		}

         	}
         }



         	if(flag_scan=='2') 
         	{
				initPortD();
				initPortE();
				initPortF();

				print_message2();

				while(1)
				{
					PORTF = 0x05;			//Select DAC channel A
					while(PORTE < 0xFF)
					{
						PORTE=0xff;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
                		for(x=0;x<250;x++);
					}		
					while(PORTE > 0x00)
					{
						PORTE=0;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
              			for(x=0;x<250;x++);
					}
					PORTFbits.RF8 = 1;
	 
				}

			}


           		if(flag_scan=='3')    
            	{

				initPortD();
				initPortE();
				initPortF();

				print_message3();

					while(1)
					{
						PORTF = 0x05;//Select DAC channel A
                     // Select DAC channet b =0x06
						while(PORTE < 0xFF)
						{
							PORTE++;
							PORTDbits.RD4 = 1;
							PORTDbits.RD4 = 0;

							if(PORTE == 0xFF)
								PORTE = 0x00;
						}

							PORTFbits.RF8 = 1;
					}

            }
         	if(flag_scan=='4') 
         	{


				initPortD();
				initPortE();
				initPortF();

				print_message4();

				while(1)
				{			
					PORTF = 0x05;//Select DAC channel A
                     // Select DAC channet b =0x06
					while(PORTE < 0xFF)
					{
						PORTE++;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
					}
						while(PORTE > 0x00)
						{
							PORTE--;
							PORTDbits.RD4 = 1;
							PORTDbits.RD4 = 0;
						}		
						PORTFbits.RF8 = 1;
				}

            } 



           if(flag_scan=='5')    
           {
				initPortD();
				initPortE();
				initPortF();

				print_message5();

				while(1)
				{

					y=0x00;
					x=0x00;

					PORTF = 0x06;
					PORTE=y;
					PORTDbits.RD4 = 1;
					PORTDbits.RD4 = 0;


					PORTF = 0x05;			//Select DAC channel A
					while(x < 0xFF)
					{
						PORTE=x;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						x++;
					}
	
					PORTF = 0x06;			//Select DAC channel B	
					while(y < 0xFF)
					{
						PORTE=y;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						y++;
					}

					PORTF = 0x05;			//Select DAC channel A
					while(x > 0x00)
					{
						PORTE=x;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						x--;
					}

					PORTF = 0x06;			//Select DAC channel B	
					while(y > 0x00)
					{
						PORTE=y;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						y--;
					}



					y=0xFF;
					x=0x00;

					while(y > 0x80 && x < 0x80)
					{

						PORTF = 0x06;
						PORTE=y;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						PORTF = 0x05;
						PORTE=x;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;

						x++;
						y--;
					}

					while(y < 0xff && x < 0xff)
					{

						PORTF = 0x06;
						PORTE=y;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
						PORTF = 0x05;
						PORTE=x;
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;

						x++;
						y++;
					}

					y=0x00;
					x=0x00;					
				
				}

				for(d=0;d<250;d++);
           }





         	if(flag_scan=='6') 
         	{


				initPortD();
				initPortE();
				initPortF();

				print_message6();

				x=0;
				y=45;
                for(x=0;x<180;x++)              
				data[x]=127+127*sin((2*3.14*x)/180);
				x=0;



				while(1)
				{			
					  	PORTF = 0x05;//Select DAC channel A
 						PORTE=data[x];
						PORTDbits.RD4 = 1;
						PORTDbits.RD4 = 0;
   						PORTF = 0x06;	//Select DAC channel B
   						PORTE=data[y];
    					PORTDbits.RD4 = 1;
    					PORTDbits.RD4 = 0;
                  		x++;
                  		y++;
         				if(x==180)x=0;
         				if(y==180)y=0;
				}

            } 

















	}
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////




void print_message1(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string1[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}




///////////////////////////////////////////////////////////////////////////////////////////




void print_message2(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string2[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}



///////////////////////////////////////////////////////////////////////////////////////////



void print_message3(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string3[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}


///////////////////////////////////////////////////////////////////////////////////////////


void print_message4(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string4[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}


///////////////////////////////////////////////////////////////////////////////////////////

void print_message5(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string5[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}

//////////////////////////////////////////////////////////////////////////////////////////

void print_message6(void)
{
	int i,data;
	PORTF = 0x00;

		for(i=0;i<7;i++)				//insert the control words
     		{
     			PORTDbits.RD5 = 0;			//RD5=0 	-> write	w/r
     		 	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
      		 	PORTE=control[i];
      		 	PORTDbits.RD4=1;			//enable=1
        	 	PORTDbits.RD4=0;			//enable=0
          	 	busy();
		}


	PORTBbits.RB15=1;					//ascii state
	for(data=0;data<16;data++)			//write the sentance on the first row
	{
		PORTE=string6[data];			
		PORTDbits.RD4=1;
		PORTDbits.RD4=0;
					
        for(i=0;i<3200;i++); 	
	}
}


///////////////////////////////////////////////////////////////////////////////////////////

void delay(int j)
{
	unsigned int i;

	for(i=0;i<j;i++);
}

/////////////////////////////////////////////////////////////////////////////////

void delay0(void)
{
	unsigned int i;
	for(i=0;i<6400;i++);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initPortD(void)
{
	unsigned int portMap;
	portMap = TRISD;
	portMap &= 0xFFFFFFCF;
	TRISD = portMap;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initPortE(void)
{
	unsigned int portMap;
	portMap = TRISE;
	portMap &= 0xFFFFFF00;
	TRISE = portMap;
	PORTE = 0x00;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initPortF(void)
{
	unsigned int portMap;
	portMap = TRISF;
	portMap &= 0xFFFFFEF8;
	TRISF = portMap;
	PORTFbits.RF8 = 1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initPortG(void)
{
	unsigned int portMap;
	portMap = TRISG;
	portMap &= 0xFFFFFFFC;
	TRISG = portMap;
	PORTG = 0x00;
}


///////////////////////////////////////////all the functions below are unused/////////////////////////////////////////////////////////////////////////


int scan_key(void)
{
		int RUN_ZERO[4] = {0xee,0xdd,0xbb,0x77};
		int scan_key_code_ascii[32]={0xee,'1',0xde,'2',0xbe,'3',0x7e,'A',
                                             0xed,'4',0xdd,'5',0xbd,'6',0x7d,'B',
                                             0xeb,'7',0xdb,'8',0xbb,'9',0x7b,'C',
                                             0xe7,'*',0xd7,'0',0xb7,'#',0x77,'D'};  
       int i,num_code;
       int  column=0;
       int  flag=0;  

       PORTG = 0x00;
       PORTF = 0x07;
       for(i=0;i<100;i++)
       {
                    PORTE = RUN_ZERO[column];
	   				delay(10);	
	    			keyVal = PORTB & 0x0F;
					if(keyVal != 0x0f)
                    { 
						flag=1;
						break;
					}

                    column++;
					if(column==4)
						column = 0;//иеш
		}

 		if(flag==1)
    	{				  
			num_code=((RUN_ZERO[column]&0xf0)|(keyVal));
          	for(i=0;i<32;i+=2)
            {              
				 if(num_code==scan_key_code_ascii[i])
                 {
					i=scan_key_code_ascii[i+1];  
                    break;
				}		 
            }
         }

		else
		i=0xff;
        return(i);
 } 


      


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initPortB(void)
{
	unsigned int portMap;

	portMap = TRISB;
	portMap &= 0xFFFF7FFF;
	TRISB = portMap;
	AD1PCFG = 0x7fff; 	//Select PORTB to be digital port input
	CNCONbits.ON = 0;
	CNEN = 0x3C;
	CNPUE = 0x3C;	    	//Set RB0 - RB3 as inputs with weak pull-up
	CNCONbits.ON = 1;
}








/////////////////////////////////////////////////////////////////////////////////////////////////////////////

void busy(void)
{
	char RD,RS;
    int STATUS_TRISE;
	
	RD=PORTDbits.RD5;			//backup data
	RS=PORTBbits.RB15;			//backup data
	STATUS_TRISE=TRISE;			//backup data

	PORTDbits.RD5 = 1;			//RD5=1 	-> status read (from the LCD)
	PORTBbits.RB15 = 0;			//RS=RB15=0 	-> control
	tris_map = TRISE;
	tris_map |= 0x80;			//we put 1 in RE7 so he wiil thinkk he is busy on the first time
	TRISE = tris_map;

	do					// we need to know that: if the leg 7 in portE = 1 -> busy ; 0x80=10000000 
	{
		PORTDbits.RD4=1;		//enable=1
		PORTDbits.RD4=0;		//enable=0
	}
	while(PORTEbits.RE7); 			// while there is 1 (busy) in leg 7 of portE

	PORTDbits.RD5=RD; 			//give RD5 and RS and TRISE the values they had before the function busy
	PORTBbits.RB15=RS;
	TRISE=STATUS_TRISE;   
}


